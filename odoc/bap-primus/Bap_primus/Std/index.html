<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Std (bap-primus.Bap_primus.Std)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">bap-primus</a> &#x00BB; <a href="../index.html">Bap_primus</a> &#x00BB; Std</nav><h1>Module <code>Bap_primus.Std</code></h1></header><aside><p>Primus - The Microexecution Framework.</p><p>Primus is a microexecution framework that can be used to implement CPU and full system emulators, symbolic executers, static fuzzers, policy checkers, tracers, quickcheck-like test suites, etc.</p><p>Primus is an extensible non-deterministic interpreter of BAP IR. Primus provides a set of extension points through which it is possible to track what it interpreter is doing, examine its state, and even change the semantics of operatons (to a limited extent). These extension points are called &quot;observations&quot; in Primus parlance. We user a simple publish/subscriber architecture, and subscriber's code is run in Primus monad that permits arbitrary mutation of the interpreter state.</p><p>Primus implements a non-deterministic compuation model (here non-deterministic is used in a sense of the non-deterministic Turning Machine, when on each executing step machine can have more than one outcome). Two non-deterministic operations are provided: <code>fork</code> that clones current computations into two identical computations and <code>switch</code> that switches between computations. Other than these two operators, non-determinism is not observable as every thread of execution (called `machine' in our parlance) sees a totally deterministic word.</p><p>Primus is built from components. The core components are:</p><ul><li>Env - provides mapping from variables to values</li><li>Memory - provides mapping from memory locations to values;</li><li>Linker - provides mapping from labels to code;</li><li>Lisp - enables Lisp-like DSL.</li></ul><p>A new component could be added to Primus to extend its behavior. A component's <code>init</code> function is evaluated when Primus starts and it usually registers handlers for observations.</p><p>The Linker is responsible for linking code into the program abstraction. The <code>Env</code> component defines the environment behavior, i.e., variables. Finally, the <code>Memory</code> component is responsible for the memory representation.</p><p>Primus framework is implemented as a monad transformer that wraps any monad into the <code>Machine</code> monad. The <code>Machine</code> monad denotes a computation, and is implemented as a composition of state, exception, and continuation passing monad.</p><p>Each user component is a functor that is parametrized by a Machine monad. It is require to provide only one function - <code>init</code>. Usually, this function subscribes to observations, but it can modify other components (depending on their interface).</p></aside><div class="spec module" id="module-Primus"><a href="#module-Primus" class="anchor"></a><code><span class="keyword">module</span> <a href="Primus/index.html">Primus</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>